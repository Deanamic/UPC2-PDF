\chapter{Various}

\section{Intervals}
	\kactlimport{IntervalContainer.h}
	\kactlimport{IntervalCover.h}
	\kactlimport{ConstantIntervals.h}

\section{Misc. algorithms}
	\kactlimport{TernarySearch.h}
	\kactlimport{Karatsuba.h}
	\kactlimport{Josephus.h}

\section{Dynamic programming}
	\kactlimport{DivideAndConquerDP.h}
	\kactlimport{KnuthDP.h}

\section{Java}
    \kactlimport[-l raw]{java.java}

\section{Debugging tricks}
	\begin{itemize}
		\item \texttt{signal(SIGSEGV, [](int) \{ \_Exit(0); \});} converts segfaults into Wrong Answers.
			Similarly one can catch SIGABRT (assertion failures) and SIGFPE (zero divisions).
			\texttt{\_GLIBCXX\_DEBUG} violations generate SIGABRT (or SIGSEGV on gcc 5.4.0 apparently).
		\item \texttt{feenableexcept(29);} kills the program on NaNs (\texttt 1), 0-divs (\texttt 4), infinities (\texttt 8) and denormals (\texttt{16}).
	\end{itemize}

\section{Optimization tricks}
	\subsection{Bit hacks}
		\begin{itemize}
			\item \texttt{x \& -x} is the least bit in \texttt{x}.
            \item \texttt{x \&\& !(x \& (x - 1))} true, if \texttt{x} is power of 2.
            \item \texttt{gray\_code[x] = x \^{} (x >> 1)}
            \item \texttt{checkerboard[y][x] = (x \& 1) \^{} (y \& 1)}
            \item \texttt{ffs(int x), ffs(ll x)} number of the least significant bit, \texttt{ffs(1 << i) = i+1}
            \item \texttt{\_\_builtin\_clz(uint x), ...\_clzll(ull)} number of leading zeros, for x > 0
            \item \texttt{\_\_builtin\_ctz(uint x), ...\_ctzll(ull)} number of trailing zeros, for x > 0
            \item \texttt{\_\_builtin\_popcount(uint x), ...\_popcountll(ull)} number of 1 bits
            \item \texttt{\#define ld\_ll(X) (63-\_\_builtin\_clzll(ll(X)))} floor(log2(X))
			\item \texttt{for (int x = m; x; ) \{ --x \&= m; ... \}} loops over all subset masks of \texttt{m} (except \texttt{m} itself).
			\item \texttt{c = x\&-x, r = x+c; (((r\^{}x) >> 2)/c) | r} is the next number after \texttt{x} with the same number of bits set.
			\item \texttt{ rep(b,0,K) rep(i,0,(1 << K)) if (i \& 1 << b) D[i] += D[i\^{}(1 << b)]; } computes all sums of subsets.
		\end{itemize}
	\subsection{Pragmas}
		\begin{itemize}
			\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize for loops and optimizes floating points better (assumes associativity and turns off denormals).
			\item \lstinline{#pragma GCC target ("avx,avx2")} can double performance of vectorized code, but causes crashes on old machines.
			\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
		\end{itemize}
